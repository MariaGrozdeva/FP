##  Задача 1:  
Да се напише функция (max-unique ll), която по списък от списъци от цели числа намира най-голямото от тези от тях, които са  
уникални в рамките на списъка, в който се срещат. Ако в никой списък няма уникални числа, функцията да връща #f.  
*(max-unique '((1 2 3 2) (5 5) (0))) --> връща 3  
(max-unique '((1 2 1 2) (5 5) ()))  --> връща #f*  

## Задача 2:  
Да се напише функция (longest-descending­ l), която намира низходящо сортиран подсписък  
на списъка от числа l с максимална дължина.  
Ако съществуват няколко такива подсписъка, функцията да върне първия отляво надясно.  
Упътване: Реализирайте помощна функция, която намира най-дългия низходящо сортиран префикс на даден списък.  
*(longest-descending '(5 3 8 6 4 2 6 7 1))     --> връща '(8 6 4 2)  
(longest-descending '(1 2 3 4 5 6))           --> връща '(1)  
(longest-descending '(5 3 8 6 4 2 6 5 4 1))   --> връща '(8 6 4 2)  
(longest-descending '(5 3 8 6 4 2 6 5 4 1 0)) --> връща '(6 5 4 1 0)*  

## Задача 3:  
Казваме, че списъкът x = (x1 x2 ... x2n) от цели числа се получава от прочитането (look-and-say) на списъка y, ако y се състои от  
последователно срещане на x1 пъти x2, последвано от x3 пъти x4, и така нататък до x2n-1 пъти x2n. Да се дефинира функция next-  
look-and-say, която по даден списък y намира списъка x, получен от прочитането y.  
*(look-and-say '(1 1 2 3 3)) --> връща ‘(2 1 1 2 2 3)*  

## Задача 4:  
Нека е даден списък l от числа и двуместна операция над числа ⊕.  
Функцията f наричаме “ендоморфизъм над l”, ако f трансформира l в себе си, запазвайки операцията ⊕, т.е.  
∀x∈l f(x)∈l и  
∀x,y∈l f(x) ⊕ f(y) = f(x ⊕ y).  
Да се реализира функция is-em?, която проверява дали f е ендоморфизъм.  
*(is-em? '(0 1 4 6) + (lambda (x) (remainder x 3))) --> връща #t*  
